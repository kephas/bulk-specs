<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="lib/rfc2629.xslt"?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>

<rfc ipr="full2026" 
     category="exp"
     docName="draft-btme-00" 
     xmlns:x="http://purl.org/net/xml2rfc/ext">
  <x:feedback template="mailto:pierre@nothos.net"/>
  <front>
    <title abbrev="BULK v1">Binary Uniform Language Kit</title>

    <author initials="P." surname="Thierry" fullname="Pierre Thierry">
      <organization>Thierry Technologies</organization>
      <address>
        <email>pierre@nothos.net</email>
      </address>
    </author>

    <date year="2013" />
    <keyword>binary</keyword>

    <abstract>
      <t>
        This specification describes a uniform, decentrally extensible and efficient format for data
        representation.
      </t>
    </abstract>

  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      <section title="Rationale">
        <t>
          This specification aims at finding an original trade-off between uniformity, generality,
          extensibility, robustness, compactness and processing speed for a data format. It is our
          opinion that every widely used existing format occupy and different position in the
          solution space for formats, hence this new design. It is also our opinion that most of
          those existing formats constitute an optimal solution for their specific use case, either
          in a absolute sense, or at least at the time of their design. But the ever-changing field
          of IT now faces new challenges that call for a new approach.
        </t>
	<section title="Definitions">
	  <t>
	    By uniformity, we mean the property of a syntax that can be parsed even by an
	    application that doesn't understand the semantics of every part of the processed
	    data. Of course, almost all syntaxes that feature uniformity contain a limited number of
	    non uniform elements. Also, uniformity really only has value in the face of extension,
	    as a fixed syntax doesn't need uniformity (it only makes the implementation simpler).
	  </t>
	  <t>
	    Almost all extensible syntaxes have their extensible part uniform to a great degree. In
	    this specification, uniformity is hence evaluated on two criteria: first, the number of
	    non uniform elements (and, incidentally, their diversity), second, the fact that the
	    uniformity of the extensible part is not a limitation to the users (i.e. that the
	    temptation to extend the language in a non-uniform way is as absent as possible).
	  </t>
	  <t>
	    A good counter-example is found in most programming languages. Adding a new branching
	    construct cannot be done in a terse way without modifying the underlying
	    implementation. Such a construct can either not be defined by user code (because of
	    evaluation rules) or in a terribly verbose and inconvenient way (with lot of boilerplate
	    code). Notable exceptions are Lisp and Haskell.
	  </t>
	  <t>
	    Also, the canonical example of a non-uniform language is a stack programming language:
	    each operator takes a number of operands from the stack. Not knowing the arity of an
	    operator makes it impossible to continue parsing, even when its evaluation was optional
	    to the final processing.
	  </t>
	</section>
	<section title="State of the art">
	  <t>
	    Uniformity, generality and extensibility are usually highly-valued traits in formats
	    design. Programming languages obviouly feature them foremost, although their generality
	    usually stops at what they are supposed to express: procedures. Most of them are
	    ill-suited to represent arbitrary data, but notable exceptions include Lisp (where "code
	    is data") and Javascript, from which a subset has been extracted to exchange data, JSON,
	    which has seen a tremendous success for this purpose. JSON may lack in generality and
	    compactness, but its design makes its parsing really straightforward and fast. All of
	    them, though, lack robustness. Some of them make it possible to extend them in a
	    relatively robust way if some discipline is followed (for example, by naming modules
	    after domaine names), but the discipline is not mandatory.
	  </t>
	  <t>
	    The SGML/XML family of formats also feature these traits and actually fare much better
	    than programming languages on the three fronts. XML namespaces also make it fairly
	    robust and there have been attempts at making it compact (Efficient XML Interchange).
	  </t>
	  <t>
	    But all the previously cited formats clearly lack compactness, although just applying
	    standard compression techniques would sacrifice only very little processing time to gain
	    huge size reductions on most of their intended use cases.
	  </t>
	  <t>
	    So-called binary formats pretty much exhibit the opposite trade-offs. Most of them are
	    not uniform to achieve better compactness. Some are specifically designed for a great
	    generality, but many lack extensibility. When they are extensible, it's never in a
	    robust way, again for reasons that have to do with compactness. They are usually
	    extremely fast to parse.
	  </t>
	</section>
      </section>
      <section title="Format overview">
	<t>
	  A BULK stream is a stream of 8-bit bytes, in big-endian order. Parsing a BULK stream
	  yields a sequence of expressions, which can be either atoms or forms, composed of
	  atoms. The syntax of forms is entirely uniform, without a single exception: a starting
	  byte marker, a sequence of atoms and an ending byte marker. Among atoms, only nil (the
	  null byte), arrays, words and fixed-sized integers have a special syntax, for efficiency
	  purposes. Even booleans and floating-point numbers follow the uniform syntax that every
	  other expression follow.
	</t>
	<t>
	  Non uniform atoms start with a marker byte, followed by a static or dynamic number of
	  bytes, depending on the type (none for nil, static for words and fixed-size integers,
	  dynamic for arrays).
	</t>
	<t>
	  Any other atom is a reference, which consists of a namespace marker (in most of the cases,
	  a single byte) followed by a identifier within this namespace (a single byte). All in all,
	  a very little sacrifice is made in compactness (apart from nil, nothing is smaller than 2
	  bytes, which means a form is 4 bytes + its content) for the benefit of a very simple
	  syntax.
	</t>
	<t>
	  A namespace marker in a BULK stream is associated by one or two simple forms to a
	  namespace identified by a UUID, thus ensuring robust extension. One of the two forms
	  declares that the stream can be processed even if the application doesn't reckognize the
	  namespace, thanks to the uniform syntax.
	</t>
      </section>
      <section title="Conventions and Terminology">
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
          NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
          described in <xref target="RFC2119">RFC 2119</xref>.
        </t>
        <t>
          Literal numerical values are provided in decimal or hexadecimal as appropriate.
          Hexadecimal literals are prefixed with <spanx style="verb">0x</spanx> to distinguish them
          from decimal literals.
        </t>
      </section>
    </section>
 
    <section title="Security Considerations" anchor="sec">
      <t>
	Parsing a BULK stream is designed to be free of side-effects for the processing application,
	apart from storing the parsed results.
      </t>
      <t>
	Arrays in BULK carry their size, so as for the application to know in advance the size of
	the data to read and store, thus making it easier to build robust code. A malicious
	software, however, may announce an array with a size choosen to get an application to
	exhaust its available memory. When a BULK stream has been completely received, an array
	bigger than the remaining data SHOULD trigger an error. When a BULK stream's size is not
	known in advance, the application SHOULD use a growable data structure.
      </t>
    </section>

    <section title="IANA Considerations">
      <t>
	This specification defines a new media type, application/bulk. Here are the informations for
	its registration to IANA:
      </t>
      <t>
	<list style="hanging">
	  <t hangText="Type name">application</t>
	  <t hangText="Subtype name">bulk</t>
	  <t hangText="Required parameters">none</t>
	  <t hangText="Optional parameters">none</t>
	  <t hangText="Encoding considerations">none, content is self-describing</t>
	  <t hangText="Security considerations">cf. <xref target="sec"/></t>
	  <t hangText="Interoperability considerations">none</t>
	  <t hangText="Published specification">this document</t>
	  <t hangText="Applications that use this media type">none so far</t>
	  <t hangText="Fragment identifier considerations">this specification defines no semantics for
	  addressing the data with a fragment identifier; a future specification could define fragment
	  identifier syntaxes to address the content by byte offset or the parsed results by their
	  number in the yielded sequence</t>
	  <t hangText="Additional information">a future specification may define a naming convention
	  for media types based on bulk with a +bulk suffix, as for XML with +xml</t>
	</list>
      </t>
    </section>

    <section title="Acknowledgements">
      <t>
	I know that I have read <eref
	target="http://www.schnada.de/grapt/eriknaggum-xmlrant.html">Erik Naggum's famous rant about
	XML</eref> in the past, and it may well have unconsciouly influenced this design. I happened
	to stumble upon it again while writing the earliest draft of this specification and it
	struck me how much it embodies his ideas. In any case, I dedicate this format to him.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <reference anchor="RFC2119">
        <front>
          <title>
            Key words for use in RFCs to Indicate Requirement Levels
          </title>
          <author initials="S." surname="Bradner" fullname="Scott Bradner">
            <organization>Harvard University</organization>
            <address><email>sob@harvard.edu</email></address>
          </author>
          <date month="March" year="1997"/>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
      </reference>
    </references>
  </back>
</rfc>

