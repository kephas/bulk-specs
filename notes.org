* BULK
  - final abstract yield = abstract yield after application of
    transformation semantics

** syntax
   - 0x00 :: nil
   - 0x01 :: (
   - 0x02 :: )
   - 0x03 :: # {dim}:Int {content}:nB
     - arrays are used whenever a vector or matrix is needed
       - the semantics of the content must be inferred by the
         application; where ambiguity can appear, an application
         SHOULD enclose the array in a type-denoting form
     - because BULK arrays have no end markers, the payload of a BULK
       stream can constitute the end of the stream
     - an array can be skipped in constant time and mapped in memory
     - unlimited size
       - # Word128 {content} is of maximum size 2^128
       - # ( bigint # Word128 {num} ) {content} is of maximum size 2^(2^128)
       - the bigint's size can be a bigint too… ad infinitam
   - 0x04 :: uw8 1B
   - 0x05 :: uw16 2B
   - 0x06 :: uw32 4B
   - 0x07 :: uw64 8B
   - 0x08 :: uw128 16B
   - 0x09 :: sw8 1B
   - 0x0A :: sw16 2B
   - 0x0B :: sw32 4B
   - 0x0C :: sw64 8B
   - 0x0D :: sw128 16B

** BULK core namespace
   NSID: 0x20

   - 0x01 :: ( version Int Int )
   - 0x02 :: true
   - 0x03 :: false
   - 0x04 :: ( stringenc {enc}:Encoding )
   - 0x05 :: ( iana-charset Int ):Encoding
   - 0x06 :: ( codepage Int ):Encoding
   - 0x07 :: ( ns {marker}:Int {id}:UniqueID )
   - 0x08 :: ( package {id}:UniqueID {namespaces} )
   - 0x09 :: ( import {base}:Int {count}:Int {uuid} )
   - 0x0A :: ( define Ref Expr )
   - 0x0B :: ( mnemonic/def {name}:Expr {mnemonic}:String {doc}:Expr {value} )
   - 0x0C :: ( ns-mnemonic {ns}:Expr {mnemonic}:String {doc} )
   - 0x0D :: ( verifiable-ns {marker}:Int {id}:UniqueID
             {mnemonic}:Expr {doc}:Expr {definitions} )
     - ( mnemonic/def nil {…} ) defines the next unattributed ref
       (starting at 0)
   - 0x0E :: ( concat {a1} {a2} )
   - 0x0F :: ( subst {code} )
   - 0x10 :: ( arg Int )
   - 0x11 :: ( rest Int )
   - 
   - 0x20 :: ( frac Int Int )
   - 0x21 :: ( bigint Array )
   - 0x22 :: ( binary {bits} )
   - 0x23 :: ( decimal {bits} )
   - 
   - 0x30 :: ( prefix-bytecode {bytecode} )
   - 0x31 :: ( prefix-bytecode* ( {arities} ) {bytecode} )
     - {arities} is a sequence of: ( Int {refs} )
   - 0x32 :: ( postfix-bytecode {bytecode} )
   - 0x33 :: ( postfix-bytecode* ( {arities} ) {bytecode} )
   - 0x34 :: ( arity Int {refs} )

** Mobile code
   - language = namespace
   - language-agnostic encoding
     - 1 lexeme = 1 ref
       - not for Python
     - preprocessor macros
   - AST encoding
   - LA/AST
     - could embed macrology if BULK reader supports it
     - separate debug symbols
       - ref ↔ name
       - BULK offset ↔ source code position
   - general use of macrology coupled with C/S content negociation
     - client advertises known namespaces
       - but only relevant, security risk otherwise
     - server disk is cheaper than bandwidth: BULK stream with
       macrology is preprocessed to get rid of macrology, both
       versions available (small w/ macros, bigger w/o)
       - possibly on-demand w/ cache
       - selective evaluation: only evaluate what the client doesn't
         support

** Lambda expressions
   #+BEGIN_SRC bulk
   ( verifiable-ns 40 {id} nil "λ"
   "This vocabulary can be used to represent functions that can be evaluated."

   ( mnemonic/def nil "lambda" "( lambda {var}:Ref {body} )" )

   ( define 0x28 0xff "This reference is intended to be used as lambda function variable." )
   ( mnemonic/def nil "a" 0x28 0xff )
   ( mnemonic/def nil "b" 0x28 0xff )
   ( mnemonic/def nil "c" 0x28 0xff )
   ( mnemonic/def nil "d" 0x28 0xff )
   ( mnemonic/def nil "e" 0x28 0xff )
   ( mnemonic/def nil "f" 0x28 0xff )
   ( mnemonic/def nil "g" 0x28 0xff )
   ( mnemonic/def nil "h" 0x28 0xff )
   ( mnemonic/def nil "i" 0x28 0xff )
   ( mnemonic/def nil "j" 0x28 0xff )
   ( mnemonic/def nil "k" 0x28 0xff )
   ( mnemonic/def nil "l" 0x28 0xff )
   ( mnemonic/def nil "m" 0x28 0xff )
   ( mnemonic/def nil "n" 0x28 0xff )
   ( mnemonic/def nil "o" 0x28 0xff )
   ( mnemonic/def nil "p" 0x28 0xff )
   ( mnemonic/def nil "q" 0x28 0xff )
   ( mnemonic/def nil "r" 0x28 0xff )
   ( mnemonic/def nil "s" 0x28 0xff )
   ( mnemonic/def nil "t" 0x28 0xff )
   ( mnemonic/def nil "u" 0x28 0xff )
   ( mnemonic/def nil "v" 0x28 0xff )
   ( mnemonic/def nil "w" 0x28 0xff )
   ( mnemonic/def nil "x" 0x28 0xff )
   ( mnemonic/def nil "y" 0x28 0xff )
   ( mnemonic/def nil "z" 0x28 0xff )

   ( mnemonic/def nil "id" "Somestimes a form is needed just to add a semantic aspect to an expression without actually changing its value for most purposes. For these cases, a reference can be given the value of id. Some processing applications will substitute their own evaluation to this one to implement that semantic." ( lambda x x ) )
   )
   #+END_SRC

** XML
   XML is pretty complex, but most of it is unused (some even advised
   not to be used, i.e. unparsed entity). The vocabulary can be split
   into loosely coupled parts:

   - document
   - DTD
   - schema
   - Relax NG

*** Document
    "urn:uuid:8e9fbe9c-2b0c-5307-bb81-edb1a7727563" (BULK,
    http://www.w3.org/XML/Core/)

    XML content, not notation: no support for entities or
    CDATA. =stringenc= can be used everywhere.

    - ( xml1.0 {content} )
    - ( xml1.1 {content} )
    - ( pi {target} {content} )
    - ( comment {content} )
    - ( element {name} {content} )
    - ( attribute {name} {value} )
    - xml: ⇔ ( rdf:prefix "http://www.w3.org/XML/1998/namespace" )
    - xmlns: ⇔ ( rdf:prefix "http://www.w3.org/2000/xmlns/" )
    - preserve ⇔ ( define preserve ( attribute ( xml: "space" )
      "preserve" ) )

    : ( define ?rfc ( subst ( pi "rfc" ( rest 0 ) ) ) )

*** Package?
    RDF + Simple XML ( + XPath )
** XPath namespace
   urn:uuid:2cdad14a-4e46-5f2d-b3e2-e105ebafa5f8 (BULK
   http://www.w3.org/TR/1999/REC-xpath-19991116)

   #+BEGIN_SRC bulk
   ( verifiable-ns 40 {id} nil "xpath"
   "This vocabulary can be used to represent XPath expressions."

   ( mnemonic/def nil "xpath" "( xpath {steps} )" )
   ( mnemonic/def nil "union" "( union {exprs} )" )
   ( mnemonic/def nil "step" "( step {axis} {test} {preds} )" )
   ( mnemonic/def nil "ancestor" nil )
   ( mnemonic/def nil "ancestor-or-self" nil )
   ( mnemonic/def nil "attribute" nil )
   ( mnemonic/def nil "child" nil )
   ( mnemonic/def nil "descendant" nil )
   ( mnemonic/def nil "descendant-or-self" nil )
   ( mnemonic/def nil "following" nil )
   ( mnemonic/def nil "following-sibling" nil )
   ( mnemonic/def nil "namespace" nil )
   ( mnemonic/def nil "parent" nil )
   ( mnemonic/def nil "preceding" nil )
   ( mnemonic/def nil "preceding-sibling" nil )
   ( mnemonic/def nil "self" nil )
   ( mnemonic/def nil "node()" nil )
   ( mnemonic/def nil "text()" nil )
   ( mnemonic/def nil "comment()" nil )
   ( mnemonic/def nil "pi()" "pi() or ( pi() {name}:String )" )
   ( mnemonic/def nil "pi()" nil )

   ( mnemonic/def nil "." "" ( step self node() ) )
   ( mnemonic/def nil ".." "" ( step parent node() ) )
   ( mnemonic/def nil "//" "" ( step descendant-or-self node() ) )

   ( mnemonic/def nil "step*" "" ( λ:lambda λ:a ( step λ:a node() ) ) )


   )
   #+END_SRC

   As a Step, {name}:QName ⇔ ( step child {name} ) ?

*** QName
    To maximize reuse between namespaces, URIRef and URIString
    expressions also have the type QName. Any Array whose content
    satisfy the NCName production also has.

** RDF namespace
   urn:uuid:ed460331-a89b-5742-a8de-907dff727779 (BULK
   [[http://www.w3.org/1999/02/22-rdf-syntax-ns#]])

   - 0x01 :: uriref ⇔ λ:id
   - 0x02 :: ( base Array )
   - 0x03 :: prefix ⇔ ( lambda u ( lambda s ( concat u s ) ) )
   - 0x04 :: rdf# ⇔ ( uriref "[[http://www.w3.org/1999/02/22-rdf-syntax-ns#]]" )
   - 0x05 :: blank
   - 0x06 :: ( plain {lang} {literal} )
   - 0x07 :: ( datatype {id}:URIRef {literal} )
   - 0x08 :: xmlliteral ⇔ ( rdf# "XMLLiteral" )
   - 0x09 :: ( triples {triples} )
   - 0x0A :: ( turtle {statements} )
   - 0x0B :: type ⇔ ( rdf# "type" )
   - 0x0C :: property ⇔ ( rdf# "Property" )
   - 0x0D :: statement ⇔ ( rdf# "Statement" )
   - 0x0E :: subject ⇔ ( rdf# "subject" )
   - 0x0F :: predicate ⇔ ( rdf# "predicate" )
   - 0x10 :: object ⇔ ( rdf# "object" )
   - 0x11 :: bag ⇔ ( rdf# "Bag" )
   - 0x12 :: seq ⇔ ( rdf# "Seq" )
   - 0x13 :: alt ⇔ ( rdf# "Alt" )
   - 0x14 :: value ⇔ ( rdf# "value" )
   - 0x15 :: list ⇔ ( rdf# "List" )
   - 0x16 :: nil ⇔ ( rdf# "nil" )
   - 0x17 :: first ⇔ ( rdf# "first" )
   - 0x18 :: rest ⇔ ( rdf# "rest" )
   - 0x19 :: plainliteral ⇔ ( rdf# "PlainLiteral" )
   - 
   - 0x20 :: this-resource
   - 0x21 :: uri


*** Differences between complete triples (3s) and turtle-like (Tl)
    In 3s, a single triple cannot cost less than 8 bytes:

    : (:A:B:C)

    For big graphs of mostly known references, this can already be a
    valuable improvement. {triples} could be a packed sequence without
    markers around triples, but that would mean that a single missing
    or superfluous expression would wreck everything that's after
    it. The fact that a triple is still a form limits the savings but
    keeps a level of robustness (but it would be possible to define a
    packing RDF form…).

    Adding another triple cannot cost less than adding 8 bytes:

    : (:A:B:C)(:A:B:D)

    In Tl, a standalone triple cannot cost less than 10 bytes:

    : (:A(:B:C))

    But adding another triple can cost as few as 2 bytes:

    : (:A(:B:C:D))

** MeTOD: Media type Optimal Description
   - type as UniqueID
     - different forms for different use cases:
       - expressing types in contexts where namespaces are available
       - expressing types concisely without overhead of using
         namespaces: concise forms forcing kinds to be 16-bits SHA3
         and types 32-bits SHA3
	 - type = 9 bytes / kind+type = 12 bytes
	 - other forms could be defined to implement the same scheme
           with other constraints (like different sizes or hashing
           algorithm if collisions occur)
   - atomic type
     - html5
     - jpeg
   - composite type
     - syntax
       - ( xml xhtml )
	 - multiple vocabularies
	   - ( xml xhtml mathml )
     - encoding
       - ( gzip tar )
       - ( base64 zip )
   - complex structures
     - ( s/mime ( multipart ( alt ( qp txt ) ( qp html5 ) ) ( base64
       zip ) ) ( base64 openpgp ) )
   - accept patterns
     - ( xml * )
     - ( xml xhtml * )
   - semantics dictated by type
     - for xml, the first subtype MUST be the type for the document
       element
     - for MIME, order of parts


   - 0x00 :: ( type {type}:Expr {params} )
   - 0x01 :: ( kind/type {kind}:Expr {type}:Expr {params} )
   - 0x02 :: *
   - 0x03 :: bulk / ( bulk {namespaces} )
   - 0x04 :: ( concise-type-sha3 {type}:Word32 )
   - 0x05 :: ( concise-kind/type-sha3 {kind}:Word16 {type}:Word32 )
   - 0x06 :: ( associate {type}:Expr {ids} )

** Dates namespace
   - Int123 := Int | Int Int | Int Int Int
   - IntsF := Int* ( Float | Int )
   - Time = Date | TimeOfDay


   - 0x01 :: ( calendar Int123 )
   - 0x02 :: ( weekdate Int123 )
   - 0x03 :: ( ordinal Int Int )
   - 0x04 :: ( time IntsF )
   - 0x05 :: ( point Date TimeOfDay )
   - 0x06 :: ( zulu Time )
   - 0x07 :: ( offset TimeOfDay Time )
   - 0x08 :: ( years IntsF )
   - 0x09 :: ( months IntsF )
   - 0x0A :: ( days IntsF )
   - 0x0B :: ( hours IntsF )
   - 0x0C :: ( minutes IntsF )
   - 0x0D :: ( seconds IntsF )
   - 0x0E :: ( weeks Int )
   - 0x0F :: ( interval {exprs} )
     - {exprs} = Time Time | Duration Time | Time Duration |
       Duration
   - 0x10 :: ( repeat Int Interval ) / ( repeat Interval )
   - 0x11 :: ( julian Number )
   - 0x12 :: ( unix-time SInt )
   - 0x13 :: ( tng-stardate Int Int )
   - 0x14 :: ( anno-mundi Int123 )
   - 0x15 :: ( anno-hegirae Int123 )


   TODO: make ISOTime also be Time and make interval accept Time

** BARF: BULK Archive Format
   - 0x01 :: ( pack {metadata}:Expr {entries} )
     - metadata
       - nil
       - any other BULK expression suited as metadata
   - 0x02 :: ( stack {metadata}:Expr {entries-metadata} ) {entries}
     - to make BULK-unaware append possible
     - {entries-metadata} means {entries} last element can be a single
       Array and the content of the entry is the end of the BULK file
   - 0x03 :: ( describe {metadata}:Expr {content} )
     - {content} can be an Array (e.g. a file's content) or BULK
   - 0x04 :: ( metadata {data} )
   - 0x05 :: ( entry {num} )
   - 0x06 :: ( bulk-stream gbc*> {size} {stream} )
     - to include a BULK stream in a pack without a surrounding array
     - {size} is number of bytes in {bulk}
       - kind of an explicitly parseable array
       - {size} can be nil
   - 0x07 :: gbc|
   - 0x08 :: gbc>
     - GBC form must not be preserved if payload is modified
   - 0x09 :: gbc*>
     - preservable GBC form
   - 0x0A :: gbc*~>
     - preservable GBC form whose payload was modified
   - 0x0B :: ( compressed gbc| {method} Array )
   - 0x0C :: deflate
   - 0x0D :: ( encrypted gbc| {method} Array )
   - 0x0E :: ( hashed gbc> {signature} Array )
   - OxOF :: ( count {num} )
   - --- Metadatum ---
   - ( path {components} )
     - by design, there is no way to express an absolute FS path
       - an application is free to define insecure forms to express
         absolute paths and links
       - TODO: what if a component contain "/"?
	 - implementation should not resolve the name but look it up
           in the directory entries (that takes care of "/" but not
           of a ".." entry, this still needs checking, shame on Unix)
   - ( user {name} )
     - {name} can be anything, incl. string and Int
       - multiple entries (e.g. "pierre"/1000)
   - ( group {name} )
   - ( dev-major {num} )
     - redundant with a xxx-dev form as entry content?
   - ( dev-minor {num} )
     - idem
   - contiguous
     - tar semantics
   - ( access {time} )
   - ( modification {time} )
   - ( change {time} )
   - ( mode {mode} )
   - ( posix-acl {acls} )
     - ( user {id} {mode} {default?} )
     - ( group {id} {mode} {defaults?} )
     - ( other {mode} {defaults?} )
     - ( mask {mode} {defaults?} )
   - ( xattr {xattr} )
     - {xattrs} = ( {name} {value} )+
   - ( offsets Int+ )
     - base is the first byte after {metadata}
   - ---
   - ( hard-link Path nil )
   - ( sym-link Path nil )
   - ( char-dev {??} nil )
   - ( block-dev {??} nil )
   - ( directory {name} nil )

** Hash
   #+BEGIN_SRC bulk
   ( verifiable-ns 40 {id} nil "hash"
   "The forms in this vocabulary can be used to represent hashes along with the hashing algorithm instead of using an unmarked byte sequence. When an algorithm has other inputs than the message, they can be provided after the hash itself as a property list.

When an algorithm can produce hashes in different sizes and the size used is a number of bits divisible by 8, the size property should be omitted from the property list and inferred by the processing application from the size of the BULK expression (e.g. `( sha3 # 24 {hash} )` is a 196-bits SHA3 hash).

As a rule, each of these forms can contain `nil` as a first expression to denote not a hash but a choice of configuration in some application context. For example, `( uuid nil prepend {ns} )` could mean that subsequent v3 and v5 UUIDs will be produced with {ns} as UUID namespace."

   ( mnemonic/def nil "bsd" "( bsd Word16 )" )
   ( mnemonic/def nil "sysv" "( sysv Word16 )" )
   ( mnemonic/def nil "crc" "( crc Word )" )
   ( mnemonic/def nil "fletcher" "( fletcher Word {config} )" )
   ( mnemonic/def nil "adler32" "( adler32 Word32 )" ( λ:lambda λ:h ( fletcher λ:h key 65521 ) ) )
   ( mnemonic/def nil "pjwhash" "( pjw Word )" )
   ( mnemonic/def nil "elfhash" "( fnv Word )" )

   ( mnemonic/def nil "murmur1" "( murmur1 Word )" )
   ( mnemonic/def nil "murmur2" "( murmur2 Word )" )
   ( mnemonic/def nil "murmur2a" "( murmur2a Word )" )
   ( mnemonic/def nil "murmur64a" "( murmur64a Word )" )
   ( mnemonic/def nil "murmur64b" "( murmur64b Word )" )
   ( mnemonic/def nil "murmur3" "( murmur3 Word )" )

   ( mnemonic/def nil "umac" "( umac Word {config} )" )
   ( mnemonic/def nil "vmac" "( vmac Word {config} )" )

   ( mnemonic/def nil "uuid" "( uuid Word128 {config} )" )
   ( mnemonic/def nil "md2" "( md2 Word128 )" )
   ( mnemonic/def nil "md4" "( md4 Word128 )" )
   ( mnemonic/def nil "md5" "( md5 Word128 )" )
   ( mnemonic/def nil "md6" "( md6 Bytes {config} )" )
   ( mnemonic/def nil "ripemd" "( ripemd Bytes )" )
   ( mnemonic/def nil "haval" "( haval Bytes )" )
   ( mnemonic/def nil "gost" "( gost Array )" )
   ( mnemonic/def nil "sha1" "( sha1 Array )" )
   ( mnemonic/def nil "sha2" "( sha2 Array )" )
   ( mnemonic/def nil "sha3" "( sha3 Bytes )" )
   ( mnemonic/def nil "tiger" "( tiger Bytes )" )
   ( mnemonic/def nil "tiger2" "( tiger2 Bytes )" )
   ( mnemonic/def nil "whirlpool" "( whirlpool Array )" )
   ( mnemonic/def nil "blake" "( blake Array )" )
   ( mnemonic/def nil "blake2" "( blake2 Bytes )" )

   ( mnemonic/def nil "size" )
   ( mnemonic/def nil "prepend" )
   ( mnemonic/def nil "append" )
   ( mnemonic/def nil "key" )
   ( mnemonic/def nil "salt" )
   ( mnemonic/def nil "rounds" )

   )
   #+END_SRC

** Asking input
   - test https://github.com/eishay/jvm-serializers?

* Redesign?
** syntax
   As inspired by CBOR

   | marker | shape                | notes                 |
   |--------+----------------------+-----------------------|
   |  00−3F | {int}                |                       |
   |  40−7F | smallarray {content} | size = (marker && 3F) |
   |     80 | nil                  |                       |
   |     81 | (                    |                       |
   |     82 | )                    |                       |
   |     83 | array Int {content}  |                       |
   |     84 | w8 1B                |                       |
   |     85 | w16 2B               |                       |
   |     86 | w32 4B               |                       |
   |     87 | w64 8B               |                       |
   |     88 | w128 16B             |                       |
   |     89 | sint Word            |                       |
   |        |                      |                       |

   - smallarray overhead: 1 byte (1.6−50%)
   - array of size 64−255 overhead: 3 bytes (1.2−4.7%)
   - array of size 256+ overhead: 4 bytes (0.006−1.6%)


   Doesn't seem that great a gain for the added complexity (and loss
   of available NS markers?).

* Implementation notes
** Semantics beyond definitions
   When implementing a processing application that gives semantics
   beyond the evaluation of expressions, to benefit from all possible
   evaluations, the application should just replace relevant
   definitions with its own implementation while evaluating the BULK
   streams defining the corresponding vocabularies (for example
   predefine them and don't let BULK definitions overwrite them).

* Bootstrapping any hashing vocabulary
  - the problem is that this vocabulary provides hashes before any way
    of expressing a hash is possible, so its own hash is expressed
    with a name inside the vocabulary
  - you read ( ns w8 0x28 ( 0x28 0x19 w64 {hashID} ) )
  - how do you get to the point where you know 0x28 0x19 is hash:sha3?
    - you get the list (hopefully with only one element) of
      vocabularies identified by a form whose sole element is a
      64-bits word {hashid}
    - for each of them, you check if 0x19 is a name associated with a
      hashing algorithm
      - if yes, you check it that hash matches the definition

* Minimal BULK
  : ( version 1 1 ) ( ns 40 ( sha3 w64 8B ) ) ( ns 41 ( sha3 w64 8B ) ) ref # w? {size} {content}
  : |<---- 8 ---->| |<-------- 19 --------->| |<-------- 19 --------->| |< 4 ->|  2/4/8

  52/54/58 bytes + content

  When doing hash bootstrapping blindly:

  : ( version 1 1 ) ( ns 41 ( sha3 w64 8B ) ) ref # w? {size} {content}
  : |<---- 8 ---->| |<-------- 19 --------->| |< 4 ->|  2/4/8

  33/35/39 bytes + content

  When a profile is known (like a specific file extension for typed blobs):

  : ( version 1 1 ) ref # w? {size} {content}
  : |<---- 8 ---->| |< 4 ->|  2/4/8

  14/16/20 bytes + content
