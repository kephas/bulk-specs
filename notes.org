* BULK
  - final abstract yield = abstract yield after application of
    transformation semantics

** stdlib
   M = marker byte

   O. nil
   1. (
   2. )
   3. Array: M <dim>:Int <content>:nB
      - arrays are used whenever a vector or matrix is needed
	- the semantics of the content must be inferred by the
          application; where ambiguity can appear, an application
          SHOULD enclose the array in a type-denoting form
      - because BULK arrays have no end markers, the payload of a BULK
        stream can constitute the end of the stream
      - an array can be skipped in constant time and mapped in memory
   4. 8 bits word: M 1B
   5. 16 bits word: M 2B
   6. 32 bits word: M 4B
   7. 64 bits word: M 8B
   8. 128 bits word: M 16N
   9. 32, 64 or 128 bits signed integer: M Word

** BULK core namespace
   NSID: 0x10

   1. ( version Int Int )
   2. true
   3. false
   4. ( stringenc <id> )
   5. ( iana-charset Int)
   6. ( codepage Int )
   7. ( ns <id>:Int <uuid>:Word128 )
   8. ( package <uuid> <namespaces> )
   9. ( import <base>:Int <count>:Int <uuid> )
   10. ( define Ref Expr )
   11. ( subst {code} )
   12. ( arg Int )
   13. ( rest Int )
   14. ---
   15. ( let ( <bindings> ) Expr+ )
       - bindings = Ref Expr [ bindings ]
   16. ( signed-ns <uuid>:Word128 <ns-uuid>:Word128 <signature>
       <definitions> )
       - error if ( define Ref Expr ) in *final abstract yield*
   17. ( openpgp <data>:Array )
   18. ( x509 <data>:Array )


   32. ( frac Int Int )
   33. ( bigint Array )
   34. ( binary <bits> )
   35. ( decimal <bits> )


   A NS could be tied to a URL where its reference definition can be
   found (with an v5 UUID hashing the URL). But if the URL stops being
   resolvable, the NS cannot be "authenticated" anymore. It seems too
   fragile.

   openpgp and x509 may come from a crypto NS instead.

   I removed the notion of required NS (not known to parser ⇒ parsing
   error). I have yet to see a relevant use case and it would probably
   make having unreadable BULK streams too easy. It defeats the
   uniform syntax…

** Mobile code
   - language = namespace
   - language-agnostic encoding
     - 1 lexeme = 1 ref
       - not for Python
     - preprocessor macros
   - AST encoding
   - LA/AST
     - could embed macrology if BULK reader supports it
     - separate debug symbols
       - ref ↔ name
       - BULK offset ↔ source code position
   - general use of macrology coupled with C/S content negociation
     - client advertises known namespaces
       - but only relevant, security risk otherwise
     - server disk is cheaper than bandwidth: BULK stream with
       macrology is preprocessed to get rid of macrology, both
       versions available (small w/ macros, bigger w/o)
       - possibly on-demand w/ cache
       - selective evaluation: only evaluate what the client doesn't
         support

** XML
   XML is pretty complex, but most of it is unused (some even advised
   not to be used, i.e. unparsed entity). The vocabulary can be split
   into loosely coupled parts:

   - document
   - DTD
   - schema
   - Relax NG

*** Document
    "urn:uuid:8e9fbe9c-2b0c-5307-bb81-edb1a7727563" (BULK,
    http://www.w3.org/XML/Core/)

    XML content, not notation: no support for entities or
    CDATA. =stringenc= can be used everywhere.

    - ( xml1.0 {content} )
    - ( xml1.1 {content} )
    - ( pi {target} {content} )
    - ( comment {content} )
    - ( element {name} {content} )
    - ( attribute {name} {value} )
    - xml: ⇔ ( rdf:prefix "http://www.w3.org/XML/1998/namespace" )
    - xmlns: ⇔ ( rdf:prefix "http://www.w3.org/2000/xmlns/" )
    - preserve ⇔ ( define preserve ( attribute ( xml: "space" )
      "preserve" ) )

    : ( define ?rfc ( subst ( pi "rfc" ( rest 0 ) ) ) )

*** Package?
    RDF + Simple XML ( + XPath )

** XPath namespace
   urn:uuid:2cdad14a-4e46-5f2d-b3e2-e105ebafa5f8 (BULK
   http://www.w3.org/TR/1999/REC-xpath-19991116)

   1. ( xpath {expr} )
      - {expr} is a sequence of Step
      - as a Step, {name}:QName ⇔ ( step child {name} )
   2. ( | {exprs} )
   3. ( step {axis} {test} {preds} )
      - ( step {axis} ) ⇔ ( step {axis} node() )
   4. . / ( step . {rest} )
      - . ⇔ ( step self node() )
   5. .. / ( step .. {rest} )
      - .. ⇔ ( step parent node() )
   6. //
      - // ⇔  ( step // node() )
   7. ancestor
   8. ancestor-or-self
   9. attribute
   10. child
   11. descendant
   12. following
   13. following-sibling
   14. namespace
   15. preceding
   16. preceding-sibling
   17. * / ( * {ns}:URIRef )
   18. node()
   19. text()
   20. comment()
   21. pi() / ( pi() {literal}:Array )

*** QName
    To maximize reuse between namespaces, URIRef and URIString
    expressions also have the type QName. Any Array whose content
    satisfy the NCName production also has.

** RDF namespace
   urn:uuid:ed460331-a89b-5742-a8de-907dff727779 (BULK
   [[http://www.w3.org/1999/02/22-rdf-syntax-ns#]])

   1. ( uriref Array )
   2. ( base Array )
   3. ( prefix <prefix> )
   4. blank
   5. ( plain <lang> <literal )
   6. ( datatype <id>:URIRef <literal> )
   7. xmlliteral
   8. ( triples <triples> )
   9. ( turtle <statements> )
   10. type
   11. Property
   12. Statement
   13. subject
   14. predicate
   15. object
   16. Bag
   17. Seq
   18. Alt
   19. value
   20. List
   21. nil
   22. first
   23. rest
   24. PlainLiteral
   25. 
   26. 
   27. 
   28. 
   29. 
   30. 
   31. 
   32. this-resource


*** Differences between complete triples (3s) and turtle-like (Tl)
    In 3s, a single triple cannot cost less than 8 bytes:

    : (:A:B:C)

    For big graphs of mostly known references, this can already be a
    valuable improvement. <triples> could be a packed sequence without
    markers around triples, but that would mean that a single missing
    or superfluous expression would wreck everything that's after
    it. The fact that a triple is still a form limits the savings but
    keeps a level of robustness.

    Adding another triple cannot cost less than adding 8 bytes:

    : (:A:B:C)(:A:B:D)

    In Tl, a standalone triple cannot cost less than 10 bytes:

    : (:A(:B:C))

    But adding another triple can cost as few as 2 bytes:

    : (:A(:B:C:D))

** MeTOD: Media type Optimal Description
   - type as UUID
     - Type = w128 UUID
   - atomic type
     - html
     - jpeg
   - composite type
     - syntax
       - ( xml xhtml )
	 - multiple vocabularies
	   - ( xml xhtml mathml )
     - encoding
       - ( gzip tar )
       - ( base64 zip )
   - complex structures
     - ( s/mime ( multipart ( alt txt html ) zip ) openpgp )
   - accept patterns
     - ( xml * )
     - ( xml xhtml * )
   - semantics dictated by type
     - for xml, the first subtype MUST be the type for the document
       element
     - for MIME, order of parts

** Dates namespace
   - Int123 := Int | Int Int | Int Int Int
   - IntsF := Int* ( Float | Int )
   - Time = Date | TimeOfDay


   1. ( calendar Int123 )
   2. ( weekdate Int123 )
   3. ( ordinal Int Int )
   4. ( time IntsF )
   5. ( point Date TimeOfDay )
   6. ( zulu Time )
   7. ( offset TimeOfDay Time )
   8. ( years IntsF )
   9. ( months IntsF )
   10. ( days IntsF )
   11. ( hours IntsF )
   12. ( minutes IntsF )
   13. ( seconds IntsF )
   14. ( weeks Int )
   15. ( interval {exprs} )
       - {exprs} = Time Time | Duration Time | Time Duration |
         Duration
   16. ( repeat Int Interval ) / ( repeat Interval )
   17. ( julian Number )
   18. ( unix-time SInt )
   19. ( tng-stardate Int Int )
   20. ( anno-mundi Int123 )
   21. ( anno-hegirae Int123 )

** BARF: BULK Archive Format
   1. ( pack {metadata} {entries} )
      - {metadata}
	- nil
	- ( Metadatum+ )
	- any other BULK expression suited as metadata
      - {entries} can be one or several arrays instead of BULK
   2. ( stack {metadata} {entries-metadata} ) {entries}
      - to make BULK-unaware append possible
      - {entries-metadata} means {entries} can be a single Array and
        the content of the entry is the end of the BULK file
   3. ( describe {metadata} {content} )
      - {metadata} as in pack
      - {content} can be an Array (e.g. a file's content) or BULK
   4. ( bulk-stream {stream} )
      - to include a BULK stream in a pack without a surrounding array
   5. ( compressed {method} Array nil )
   6. ( encrypted {method} Array nil )
   7. --- Metadatum ---
   8. ( path {components} )
      - by design, there is no way to express an absolute FS path
	- an application is free to define insecure forms to express
          absolute paths and links
	- TODO: what if a component contain "/"?
	  - implementation should not resolve the name but look it up
            in the directory entries (that takes care of "/" but not
            of a ".." entry, this still needs checking, shame on Unix)
   9. ( user {name} )
      - {name} can be anything, incl. string and Int
	- multiple entries (e.g. "pierre"/1000)
   10. ( group {name} )
   11. ( dev-major {num} )
       - redundant with a xxx-dev form as entry content?
   12. ( dev-minor {num} )
       - idem
   13. contiguous
       - tar semantics
   14. ( access {time} )
   15. ( modification {time} )
   16. ( change {time} )
   17. ( mode {mode} )
   18. ( posix-acl {acls} )
       - ( user {id} {mode} {default?} )
       - ( group {id} {mode} {defaults?} )
       - ( other {mode} {defaults?} )
       - ( mask {mode} {defaults?} )
   19. ( xattr {xattr} )
       - {xattrs} = ( {name} {value} )+
   20. ( offsets Int+ )
       - base is the first byte after {metadata}
   21. ---
   22. ( hard-link Path nil )
   23. ( sym-link Path nil )
   24. ( char-dev {??} nil )
   25. ( block-dev {??} nil )
   26. ( directory {name} nil )
   27. ( known-size {size}:Int {bulk} )
       - {size} is number of bytes in {bulk}
       - kind of an explicitly parseable array
       - alternative to =offsets=

*** Guaranteed Backward Compatibility
    - pass-through :: ( Ref {arguments} {payload}:Expr )
    - opaque :: ( Ref {arguments} nil )

** Asking input
   - test https://github.com/eishay/jvm-serializers?

* Redesign?
** stdlib
   | marker | shape                | notes                 |
   |--------+----------------------+-----------------------|
   |  00−3F | {int}                |                       |
   |  40−7F | smallarray {content} | size = (marker && 3F) |
   |     80 | nil                  |                       |
   |     81 | (                    |                       |
   |     82 | )                    |                       |
   |     83 | array Int {content}  |                       |
   |     84 | w8 1B                |                       |
   |     85 | w16 2B               |                       |
   |     86 | w32 4B               |                       |
   |     87 | w64 8B               |                       |
   |     88 | w128 16B             |                       |
   |     89 | sint Word            |                       |
   |        |                      |                       |

   - smallarray overhead: 1 byte (1.6−50%)
   - array of size 64−255 overhead: 3 bytes (1.2−4.7%)
   - array of size 256+ overhead: 4 bytes (0.006−1.6%)
