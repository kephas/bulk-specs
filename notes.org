* BULK
  - final abstract yield = abstract yield after application of
    transformation semantics

** stdlib
   M = marker byte

   O. nil
   1. (
   2. )
   3. Array: M <dim>:Int <content>:nB
      - arrays are used whenever a vector or matrix is needed
	- the semantics of the content must be inferred by the
          application; where ambiguity can appear, an application
          SHOULD enclose the array in a type-denoting form
      - because BULK arrays have no end markers, the payload of a BULK
        stream can constitute the end of the stream
      - an array can be skipped in constant time and mapped in memory
   4. 8 bits word: M 1B
   5. 16 bits word: M 2B
   6. 32 bits word: M 4B
   7. 64 bits word: M 8B
   8. 128 bits word: M 16N
   9. 32, 64 or 128 bits signed integer: M Word

** BULK core namespace
   NSID: 0x10

   1. ( version Int Int )
   2. true
   3. false
   4. ( stringenc <id> )
   5. ( iana-charset Int)
   6. ( codepage Int )
   7. ( ns <id>:Int <uuid>:Word128 )
   8. ( ns* <id>:Int <uuid>:Word128 )
   9. ( package <uuid> <namespaces> )
   10. ( import <base>:Int <uuid> )
   11. ( define <id> Expr )
       - <id> = Ref | Int8
   12. ( subst {code} )
   13. ( arg Int )
   14. ( rest Int )
   15. ( named Ref Expr )
   16. ---
   17. ( let ( <bindings> ) Expr+ )
       - bindings = Ref Expr [ bindings ]
   18. ( named* Ref Expr )
       - allows recursive definition
   19. ( signed-ns <uuid>:Word128 <ns-uuid>:Word128 <signature>
       <definitions> )
       - error if ( define Ref Expr ) in *final abstract yield*
   20. ( openpgp <data>:Array )
   21. ( x509 <data>:Array )


   32. ( frac Int Int )
   33. ( bigint Array )
   34. ( binary <bits> )
   35. ( decimal <bits> )


   A NS could be tied to a URL where its reference definition can be
   found (with an v5 UUID hashing the URL). But if the URL stops being
   resolvable, the NS cannot be "authenticated" anymore. It seems too
   fragile.

   openpgp and x509 may come from a crypto NS instead.

** Mobile code
   - language = namespace
   - language-agnostic encoding
     - 1 lexeme = 1 ref
       - not for Python
     - preprocessor macros
   - AST encoding
   - LA/AST
     - could embed macrology if BULK reader supports it
     - separate debug symbols
       - ref ↔ name
       - BULK offset ↔ source code position
   - general use of macrology coupled with C/S content negociation
     - client advertises known namespaces
       - but only relevant, security risk otherwise
     - server disk is cheaper than bandwidth: BULK stream with
       macrology is preprocessed to get rid of macrology, both
       versions available (small w/ macros, bigger w/o)
       - possibly on-demand w/ cache
       - selective evaluation: only evaluate what the client doesn't
         support

** XML
   XML is pretty complex, but most of it is unused (some even advised
   not to be used, i.e. unparsed entity). The vocabulary can be split
   into loosely coupled parts:

   - document
   - DTD
   - schema
   - Relax NG

*** Document
    "urn:uuid:8e9fbe9c-2b0c-5307-bb81-edb1a7727563" (BULK,
    http://www.w3.org/XML/Core/)

    XML content, not notation: no support for entities or
    CDATA. =stringenc= can be used everywhere.

    - ( xml1.0 {content} )
    - ( xml1.1 {content} )
    - ( pi {target} {content} )
    - ( comment {content} )
    - ( element {name} {content} )
    - ( attribute {name} {value} )
    - xml: ⇔ ( prefix xml: "http://www.w3.org/XML/1998/namespace" )
    - xmlns: ⇔ ( prefix xml: "http://www.w3.org/2000/xmlns/" )
    - preserve ⇔ ( define preserve ( attribute ( xml: "space" )
      "preserve" ) )

    : ( define ?rfc ( subst ( pi "rfc" ( rest 0 ) ) ) )

** RDF namespace
   urn:uuid:ed460331-a89b-5742-a8de-907dff727779 (BULK
   [[http://www.w3.org/1999/02/22-rdf-syntax-ns#]])

   1. ( uriref Array )
   2. ( base Array )
   3. ( prefix <pre>:Ref # Int <begin> )
   4. blank
   5. ( plain <lang> <literal )
   6. ( datatype <id>:URIRef <literal> )
   7. xmlliteral
   8. ( triples <triples> )
   9. ( turtle <statements> )
   10. type
   11. Property
   12. Statement
   13. subject
   14. predicate
   15. object
   16. Bag
   17. Seq
   18. Alt
   19. value
   20. List
   21. nil
   22. first
   23. rest
   24. PlainLiteral
   25. 
   26. 
   27. 
   28. 
   29. 
   30. 
   31. 
   32. this-resource


*** Differences between complete triples (3s) and turtle-like (Tl)
    In 3s, a single triple cannot cost less than 8 bytes:

    : (:A:B:C)

    For big graphs of mostly known references, this can already be a
    valuable improvement. <triples> could be a packed sequence without
    markers around triples, but that would mean that a single missing
    or superfluous expression would wreck everything that's after
    it. The fact that a triple is still a form limits the savings but
    keeps a level of robustness.

    Adding another triple cannot cost less than adding 8 bytes:

    : (:A:B:C)(:A:B:D)

    In Tl, a standalone triple cannot cost less than 10 bytes:

    : (:A(:B:C))

    But adding another triple can cost as few as 2 bytes:

    : (:A(:B:C:D))

** MeTOD: Media type Optimal Description
   - type as UUID
     - Type = w128 UUID
   - atomic type
     - html
     - jpeg
   - composite type
     - syntax
       - ( xml xhtml )
	 - multiple vocabularies
	   - ( xml xhtml mathml )
     - encoding
       - ( gzip tar )
       - ( base64 zip )
   - complex structures
     - ( s/mime ( multipart ( alt txt html ) zip ) openpgp )
   - accept patterns
     - ( xml * )
     - ( xml xhtml * )
   - semantics dictated by type
     - for xml, the first subtype MUST be the type for the document
       element
     - for MIME, order of parts

** Dates namespace
   - Int123 := Int | Int Int | Int Int Int
   - IntsF := Int* ( Float | Int )
   - Time = Date | TimeOfDay


   1. ( calendar Int123 )
   2. ( weekdate Int123 )
   3. ( ordinal Int Int )
   4. ( time IntsF )
   5. ( point Date TimeOfDay )
   6. ( zulu Time )
   7. ( offset TimeOfDay Time )
   8. ( years IntsF )
   9. ( months IntsF )
   10. ( days IntsF )
   11. ( hours IntsF )
   12. ( minutes IntsF )
   13. ( seconds IntsF )
   14. ( weeks Int )
   15. ( interval {exprs} )
       - {exprs} = Time Time | Duration Time | Time Duration |
         Duration
   16. ( repeat Int Interval ) / ( repeat Interval )
   17. ( julian Number )
   18. ( unix-time SInt )
   19. ( tng-stardate Int Int )
   20. ( anno-mundi Int123 )
   21. ( anno-hegirae Int123 )

** Asking input
   - test https://github.com/eishay/jvm-serializers?

