* BULK
  - final abstract yield = abstract yield after application of
    transformation semantics

** stdlib
   M = marker byte

   O. nil
   1. (
   2. )
   3. Array: M <dim>:Int <content>:nB
      - arrays are used whenever a vector or matrix is needed
	- an application is free to pack any kind of data
	- the semantics of the content must be inferred by the
          application; where ambiguity can appear, an application
          SHOULD enclose the array in a type-denoting form
      - because BULK arrays have no end markers, the payload of a BULK
        stream can constitute the end of the stream
      - an array can be skipped in constant time and mapped in memory
   4. 32 bits word: M 4B
   5. 64 bits word: M 8B
   6. 128 bits word: M 16N
   7. 8 bits unsigned integer: M 1B
   8. 32, 64 or 128 bits unsigned integer: M Word
   9. 32, 64 or 128 bits signed integer: M Word

** BULK core namespace
   NSID: 0x10

   1. ( version Int Int )
   2. ( ns <id>:Int <uuid>:Word128 )
   3. ( ns* <id>:Int <uuid>:Word128 )
   4. ( stringenc <id> )
   5. ( iana-charset Int)
   6. ( codepage Int )
   7. true
   8. false

*** rearranged NS
    1. ( version Int Int )
    2. true
    3. false
    4. ( stringenc <id> )
    5. ( iana-charset Int)
    6. ( codepage Int )
    7. ( ns <id>:Int <uuid>:Word128 )
    8. ( ns* <id>:Int <uuid>:Word128 )
    9. optional: used in package form
       - if it is not confusing to spec readers, (option <uuid>) in
         package forms could be replaced by (ns* <uuid>) to spare a
         name in Ox10
    10. ( package <uuid> <namespaces> )
    11. ( import <base>:Int <uuid> )
    12. ( define <id> Expr )
        - <id> = Ref | Int8
    13. ( let ( <bindings> ) Expr+ )
        - bindings = Ref Expr [ bindings ]
    14. ( signed-ns <uuid>:Word128 <ns-uuid>:Word128 <signature>
        <definitions> )
        - <uuid> is a v5 UUID generated with <ns-uuid> and <signature>
        - <signature> is the signature of <definitions>
        - expressions in <definitions> must have the shape ( define
          Int8 Expr ) to define something within <uuid>
          - error if ( define Ref Expr ) in final abstract yield
    15. ( openpgp <data>:Array )
    16. ( x509 <data>:Array )
    17. 
    18. 
    19. 
    20. 
    21. 
    22. 
    23. 
    24. 
    25. 
    26. 
    27. 
    28. 
    29. 
    30. 
    31. 
    32. ( frac Int Int )
    33. ( bigint Array )
    34. ( binary <bits> )
    35. ( decimal <bits> )


    A NS could be tied to a URL where its reference definition can be
    found (with an v5 UUID hashing the URL). But if the URL stops being
    resolvable, the NS cannot be "authenticated" anymore. It seems too
    fragile.

    openpgp and x509 may come from a crypto NS instead.

*** import
    #+BEGIN_src lisp
      ( package P N1 ( optional N2 ) N3 )
      ( import k P )
    #+END_src

    is equivalent to:

    #+BEGIN_src lisp
      ( ns k N1 )
      ( ns* k+1 N2 )
      ( ns k+2 N3 )
    #+END_src

*** definitions
    To define a reference is to associate an expression to this name
    in its namespace (as identified by its UUID, not NSID). The scope
    of a definition is the part of its context that follows the
    definition.

    The semantics of an association are entirely
    application-dependent, but the default semantics is that wherever
    the reference appears in the definition's scope, the expression
    that has been associated can be substituted to the reference in
    the abstract yield.

    After the third expression in the following stream, the name 0x1
    in namespace Ox21 is associated with 42:

    #+BEGIN_src lisp
      (ns Ox20 0xa2a97ec685f95aed89b27ca3cafc2093)
      (ns Ox21 0xa2a97ec685f95aed89b27ca3cafc2093)
      (define Ox20 Ox1 42)
    #+END_src

*** sealed namespaces
    A specification or an application-specific logic MAY declare a
    namespace as sealed. I

** XML Infoset namespace
   urn:uuid:a2a97ec6-85f9-5aed-89b2-7ca3cafc2093 (BULK
   http://www.w3.org/TR/2004/REC-xml-infoset-20040204/)

   1. Infoset
   2. Document
   3. Element
   4. Attribute
   5. Processing instruction
   6. Unexpanded entity
   7. Comment
   8. DTD
   9. Unparsed entity
   10. Notation
   11. NS

** URI namespace
   1. ( uriref Array )
   2. ( base Array )
   3. ( prefix Ref Array )

** RDF namespace
   urn:uuid:ed460331-a89b-5742-a8de-907dff727779 (BULK
   [[http://www.w3.org/1999/02/22-rdf-syntax-ns#]])

   1. ( triple <subj> <pred> <obj> )
   2. ( triples <triples> )
   3. ( turtle <statements )


*** Differences between complete triples (3s) and turtle-like (Tl)
    In 3s, a single triple cannot cost less than 8 bytes:

    : (:A:B:C)

    Adding another triple cannot cost less than adding 8 bytes:

    : (:A:B:C)(:A:B:D)

    In Tl, a standalone triple cannot cost less than 12 bytes:

    : (:A(:B(:C)))

    Adding another triple can cost as few as 2 bytes:

    : (:A(:B(:C:D)))
 
** Efficient XML/BULK transformation
   BULK equivalent to XML Schema, used by an application to compact
   XML to the fullest.

   - enumeration attributes become a single reference instead of a
     form enclosing a string
   - macrology may be defined to further compact common use cases

** Asking input
   - test https://github.com/eishay/jvm-serializers?
