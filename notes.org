* BULK
  - final abstract yield = abstract yield after application of
    transformation semantics

** stdlib
   M = marker byte

   O. nil
   1. (
   2. )
   3. Array: M <dim>:Int <content>:nB
      - arrays are used whenever a vector or matrix is needed
	- the semantics of the content must be inferred by the
          application; where ambiguity can appear, an application
          SHOULD enclose the array in a type-denoting form
      - because BULK arrays have no end markers, the payload of a BULK
        stream can constitute the end of the stream
      - an array can be skipped in constant time and mapped in memory
   4. 32 bits word: M 4B
   5. 64 bits word: M 8B
   6. 128 bits word: M 16N
   7. 8 bits unsigned integer: M 1B
   8. 32, 64 or 128 bits unsigned integer: M Word
   9. 32, 64 or 128 bits signed integer: M Word

** BULK core namespace
   NSID: 0x10

   1. ( version Int Int )
   2. ( ns <id>:Int <uuid>:Word128 )
   3. ( ns* <id>:Int <uuid>:Word128 )
   4. ( stringenc <id> )
   5. ( iana-charset Int)
   6. ( codepage Int )
   7. true
   8. false

*** rearranged NS
    1. ( version Int Int )
    2. true
    3. false
    4. ( stringenc <id> )
    5. ( iana-charset Int)
    6. ( codepage Int )
    7. ( ns <id>:Int <uuid>:Word128 )
    8. ( ns* <id>:Int <uuid>:Word128 )
    9. ( package <uuid> <namespaces> )
    10. ( import <base>:Int <uuid> )
    11. ( define <id> Expr )
        - <id> = Ref | Int8
    12. ( let ( <bindings> ) Expr+ )
        - bindings = Ref Expr [ bindings ]
    13. ( signed-ns <uuid>:Word128 <ns-uuid>:Word128 <signature>
        <definitions> )
	- error if ( define Ref Expr ) in *final abstract yield*
    14. ( openpgp <data>:Array )
    15. ( x509 <data>:Array )
    16. 
    17. 
    18. 
    19. 
    20. 
    21. 
    22. 
    23. 
    24. 
    25. 
    26. 
    27. 
    28. 
    29. 
    30. 
    31. 
    32. ( frac Int Int )
    33. ( bigint Array )
    34. ( binary <bits> )
    35. ( decimal <bits> )


    A NS could be tied to a URL where its reference definition can be
    found (with an v5 UUID hashing the URL). But if the URL stops being
    resolvable, the NS cannot be "authenticated" anymore. It seems too
    fragile.

    openpgp and x509 may come from a crypto NS instead.

*** import
    #+BEGIN_src lisp
      ( package P N1 ( optional N2 ) N3 )
      ( import k P )
    #+END_src

    is equivalent to:

    #+BEGIN_src lisp
      ( ns k N1 )
      ( ns* k+1 N2 )
      ( ns k+2 N3 )
    #+END_src

*** definitions
    After the third expression in the following stream, the name 0x1
    in namespace Ox21 is associated with 42:

    #+BEGIN_src lisp
      (ns Ox20 0xa2a97ec685f95aed89b27ca3cafc2093)
      (ns Ox21 0xa2a97ec685f95aed89b27ca3cafc2093)
      (define Ox20 Ox1 42)
    #+END_src

*** sealed namespaces
    A specification or an application-specific logic MAY declare a
    namespace as sealed. I

** XML Infoset namespace
   urn:uuid:a2a97ec6-85f9-5aed-89b2-7ca3cafc2093 (BULK
   http://www.w3.org/TR/2004/REC-xml-infoset-20040204/)

   1. Infoset
   2. Document
   3. Element
   4. Attribute
   5. Processing instruction
   6. Unexpanded entity
   7. Comment
   8. DTD
   9. Unparsed entity
   10. Notation
   11. NS

** RDF namespace
   urn:uuid:ed460331-a89b-5742-a8de-907dff727779 (BULK
   [[http://www.w3.org/1999/02/22-rdf-syntax-ns#]])

   1. ( uriref Array )
   2. ( base Array )
   3. ( prefix <pre>:Ref # Int <begin> )
   4. blank
   5. ( plain <lang> <literal )
   6. ( datatype <id>:URIRef <literal> )
   7. xmlliteral
   8. ( triples <triples> )
   9. ( turtle <statements> )
   10. type
   11. Property
   12. Statement
   13. subject
   14. predicate
   15. object
   16. Bag
   17. Seq
   18. Alt
   19. value
   20. List
   21. nil
   22. first
   23. rest
   24. 
   25. 
   26. 
   27. 
   28. 
   29. 
   30. 
   31. 
   32. this-resource


*** Differences between complete triples (3s) and turtle-like (Tl)
    In 3s, a single triple cannot cost less than 8 bytes:

    : (:A:B:C)

    For big graphs of mostly known references, this can already be a
    valuable improvement. <triples> could be a packed sequence without
    markers around triples, but that would mean that a single missing
    or superfluous expression would wreck everything that's after
    it. The fact that a triple is still a form limits the savings but
    keeps a level of robustness.

    Adding another triple cannot cost less than adding 8 bytes:

    : (:A:B:C)(:A:B:D)

    In Tl, a standalone triple cannot cost less than 10 bytes:

    : (:A(:B:C))

    But adding another triple can cost as few as 2 bytes:

    : (:A(:B:C:D))

** Efficient XML/BULK transformation
   BULK equivalent to XML Schema, used by an application to compact
   XML to the fullest.

   - enumeration attributes become a single reference instead of a
     form enclosing a string
   - macrology may be defined to further compact common use cases

** Asking input
   - test https://github.com/eishay/jvm-serializers?
